{"meta":{"title":"纪国锐","subtitle":null,"description":null,"author":"Paris Jee","url":"http://paris-jee.github.io"},"pages":[{"title":"about","date":"2018-06-26T08:14:11.000Z","updated":"2018-06-26T08:14:11.222Z","comments":true,"path":"about/index.html","permalink":"http://paris-jee.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux 命令","slug":"Linux-命令","date":"2018-07-18T10:40:41.000Z","updated":"2018-07-18T11:15:26.477Z","comments":true,"path":"2018/07/18/Linux-命令/","link":"","permalink":"http://paris-jee.github.io/2018/07/18/Linux-命令/","excerpt":"","text":"Linux命令文件浏览命令格式： 命令 [option] file cat 由第一行开始显示文件内容 tac 从最后一行开始显示，tac 是 cat 的倒写 nl 显示行号 -b a ：空行也列出行号(类似 cat -n)； -b t ：非空行才列出行号(默认值)； more 一页一页的显示文件内容 [空格键]下一页，[Backspace]上一页。 +n 从笫n行开始显示 -n 定义屏幕大小为n行 -c 清屏显示 less 与 more 类似，但他可以往前翻页 [空格键] 滚动一行， [回车键] 滚动一页，[pagedown]： 下一页，[pageup]：上一页 head 看头几行， -n 设定行数 tail 看尾部几行 -f 循环读取 tail -100f catalina.out od 以二进制的方式读取文件内容 文件目录操作命令 mkdir -m：mode 设定权限 -p：parents 创建父级目录 mkdir -m 777 -p dir1/dir2 rm -r 递归 -f force 强行删除，忽略不存在的文件，系统不再提示 rm -rf dir mv -b ：覆盖前先备份 -f ：force 强制覆盖 -i ：询问是否覆盖 mv 1.txt 2.txt 可用于重命名 ls命令 列出目录中所有子目录和文件-a, –all 列出目录下的所有文件，包括以.开头的隐含文件-l 列出目录或文件的详细信息，包括文件的权限、所有者、文件大小等-R, –recursive 递归查询 -r, –reverse 依相反次序排列 -t 以文件修改时间排序-F 显示文件类型（File type），在列出的文件名后添加符号：/ 表明是一个目录；@ 表明是到其它文件的符号链接； 表明是一个可执行文件。ls -l s 列出当前目录中所有以“s”开头的目录的详细内容ls -F /opt/soft |grep /$ 只列出文件下的子目录ls -ltr s* 列出目录下以s 开头的档案，愈新的排愈后面ls | sed “s:^:pwd/:” 列出文件的绝对路径 tar 为linux的文件和目录创建档案tar [主选项+辅选项] 文件或目录主选项：【每条命令只能有一个主选项】-c: –create 新建一个压缩文档，即打包 -x: –extract,–get 解压文件t: –list 查看压缩文档里的所有内容 -r:–append 向压缩文档里追加文件 -u:–update 更新原压缩包中的文件辅助选项：-z 支持gzip解压文件-j 支持bzip2解压文件-Z 支持compress解压文件-v 显示操作过程-f 指定压缩文件-t 显示压缩文件的内容-d 记录文件的差别-W 确认压缩文件的正确性-l 文件系统边界设置-k 保留原有文件不覆盖-m 保留文件不被覆盖 tar -cvf log.tar 1.log 2.log 仅打包，不压缩！ tar -tf log.tar 不解压的情况下查看 gzip-a 使用ASCII文字模式 -d 解压文件 -l 列出压缩文件的详细信息 -r 递归处理 -v 显示指令执行过程-num 用指定的数字num调整压缩的速度，-1或–fast表示最快压缩方法（低压缩比），-9或–best表示最慢压缩方法（高压缩比）。系统缺省值为6。gzip / gzip -dv 压缩和解压缩文件或目录，若当前目录下有10个文件则生成10个.gz的压缩包，gzip没有打包功能文件查找命令 find命令 在目录结构中搜索文件格式：find pathname -options [-print -exec -ok …] which命令 查看可执行文件的位置 whereis命令 定位文件在文件系统中的位置 locate命令 配合数据库查看文件位置 文件权限设置命令 chmod命令权限分为只读r、只写w 和 可执行x，用户分为 文件所有者u、同组用户g、其他用户o 和 所有的用户及群组a1）文字设定法: chmod ［who］ ［+ | - | =］ ［mode］ 文件名2）数字设定法: chmod ［mode］ 文件名 数字属性的mode为3个数字，按顺序表示（u）（g）（o）对应的权限。r=4，w=2，x=1 ，- 为0 表示删除权限 rwx属性为4+2+1=7 ； rw-属性则4+2=6；r-x属性则4+1=5。 chmod ug+w,o-x test.log ; chmod -R 777 dir chgrp命令 （change group） 改变文件或目录所属的用户组 chown命令（change owner） 改变文件或目录的所有者和所属的用户组","categories":[{"name":"Linux","slug":"Linux","permalink":"http://paris-jee.github.io/categories/Linux/"}],"tags":[{"name":"-Linux命令","slug":"Linux命令","permalink":"http://paris-jee.github.io/tags/Linux命令/"}]},{"title":"Linux 文件系统","slug":"Linux-文件系统","date":"2018-07-17T02:35:18.000Z","updated":"2018-07-17T03:00:14.303Z","comments":true,"path":"2018/07/17/Linux-文件系统/","link":"","permalink":"http://paris-jee.github.io/2018/07/17/Linux-文件系统/","excerpt":"","text":"Linux 文件系统文件系统概述 文件系统是一种组织计算机文件和资料的方法； 操作系统中封装的系统服务程序，实际上是一个软件程序，用来存储和管理计算机文件和资料。 文件系统分类 磁盘文件系统：NTFS（Windows下），EXT3（linux下，基于日志）； 闪存文件系统（u盘）：JFFS2，YAFFS； 数据库文件系统：BFFS，WINFS； 网络文件系统：NFS； 虚拟文件系统：VFS（Proc）； 虚拟文件系统：在不同的文件系统，它的文件的定义和实现方式都不太一样，所以这些文件的移植性比较困难，虚拟文件系统针对不同的标准定义了一个标准的接口，也就是标准的实现方式，这些不同的标准接口，通过虚拟文件系统进行了一个处理，面向我们用户使用者来说，都是使用的同一个标准，由虚拟文件系统转换成具体的文件系统的方式。 文件系统功能 能定义文件的组织方式：文件结构； 提供建立和存取文件的环境：目录和文件； 能对文件存储器空间进行组织和分配； 负责文件存储并对存入的文件进行保护和检索； 负责建立文件，存入、读出、修改、转储文件，控制文件的存取，撤销文件等。 linux文件系统特点 EXT3是基于日志方式的文件系统；系统中每个文件都是有索引，用户对对文件的每一个操作都会记录日志，形成一个任务队列排着执行 （可以监控用户对文件系统的操作，比如：用户在进行操作的时候发生了什么错误，或者类似于崩溃这样的问题，它可以通过得到相应的记录从而进行很好地检修或更改修复，同时把用户的操作记录成日志后，它不会马上去执行，可以 形成一个任务队列排着一个一个执行）， 性能比较好。 swap是交换分区的文件系统，类似windows的虚拟内存虚拟内存的实现：两种方式。第一种是进行内存的排列像内存池一样，进行一个优化。第二种是把硬盘上的空间模拟成内存。swap是Linux的虚拟内存，在安装时要设好大小，是物理内存的2倍（安装红帽会进行设置）。 特点 Linux系统中一切皆文件Linux系统把设备(硬盘、软驱、光驱等)都看作文件，文件夹也看作文件（文件没有扩展名）。 Linux文件类型普通文件目录文件链接文件块设备字符设备Socket管道文件 Linux文件属性（不同的版本可能不同）蓝色：目录绿色：可执行浅蓝色：链接红色：压缩灰色：其他Pwd:可以看到当前目录### 根目录下的bin，这里有很多的可执行文件etc目录，这个是配置文件dev：设备目录 文件系统目录根目录下有很多子目录，不同的目录有不同的功能：var是存放变量，usr是用户的相关文件，有源文件，可执行文件，需要用到的包含文件，函数库和用户自己的程序等。linux操作系统区分大小写。 Linux与Windows目录结构的区别 根目录：Linux：/；Windows：\\ 命名大小写区分：Linux：命名区分大小写；Windows：命名不区分大小写 结构管理Linux：磁盘逻辑结构管理物理结构，格式化将磁盘分为很多的文件块区；Windows：物理结构管理逻结构，先分区再格式化建立结构。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://paris-jee.github.io/categories/Linux/"}],"tags":[{"name":"-Linux -文件系统","slug":"Linux-文件系统","permalink":"http://paris-jee.github.io/tags/Linux-文件系统/"}]},{"title":"Linux","slug":"Linux","date":"2018-07-17T02:24:37.000Z","updated":"2018-07-17T02:33:32.754Z","comments":true,"path":"2018/07/17/Linux/","link":"","permalink":"http://paris-jee.github.io/2018/07/17/Linux/","excerpt":"","text":"Linux一个linux组成至少有三个部分： kernel：内核，包围在硬件之上作用管理设备、进程、内存、交换空间、文件系统、精灵进程等；控制系统程序与硬件之间打交道的功能； shell：外壳，包裹在内核之上提供人机交互界面，用户与内核之间打交道的功能，类似Windows的cmd.分类：不同shell，命令解释不一样命令提示符：不同shell的命令提示符不一样sh,Bash（常用的shell）：#root(超级用户) $user（普通用户） //可以通过符号区分是超级用户还是普通用户csh：#root %userFileSystem：文件系统，管理文件、目录 Linux特性多用户，多任务（进程、线程处理），多平台（linux操作系统大部分代码都是由c语言来写的，c语言具有比较好的移植性，尤其是对于不同的硬件平台），图形化界面 （x-window）硬件支持（低配置），通信与联网，应用程序支持（编辑器、编程工具、数据库、办公软件、图形处理、Internet应用、游戏等）。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://paris-jee.github.io/categories/Linux/"}],"tags":[{"name":"-Linux","slug":"Linux","permalink":"http://paris-jee.github.io/tags/Linux/"}]},{"title":"HTTP 协议","slug":"HTTP-协议","date":"2018-07-17T01:54:55.000Z","updated":"2018-07-17T02:24:14.298Z","comments":true,"path":"2018/07/17/HTTP-协议/","link":"","permalink":"http://paris-jee.github.io/2018/07/17/HTTP-协议/","excerpt":"","text":"HTTP 协议1.简单来说http协议是一种无状态、B/S（浏览器和服务器）模式应用层协议，多基于TCP协议。2.http协议都包含什么内容？因为http协议它是一种浏览器、服务器模式的应用程序，那么它肯定包含请求也包含响应，这里我要了解的是请求里面包含些什么东西，和响应里面还包含什么东西请求里面报文的格式包括报头、正文、URI，然后还有请求方法和请求头等响应里面包括响应的状态码、消息报头还有响应正文 常见请求头 “user-aget”“cookle” “Referrer”常见响应头 ”Content-Type” “Content-Length” “Cache”常见状态码 状态码中的“2xx”表示请求是成功的或者是传出内容，“3xx”表示跳转，“4xx”表示客户端请求错误，“5xx”表示服务器端错误。 因为前面有提到http是一种无连接，无状态的一种协议，就是在两个请求之间，下一个请求是不知道上一个请求的状态的，所以为了解决这个问题就引入了“cookie”。 referer 就是跳转到当前的这个页面，我是从哪个页面来的，这个在做网站统计的时候是非常有用的东西，因为这个referer在浏览器的安全策略里面是不允许改的，就是别人是控制不了这个referer。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://paris-jee.github.io/categories/HTTP/"}],"tags":[{"name":"-HTTP协议","slug":"HTTP协议","permalink":"http://paris-jee.github.io/tags/HTTP协议/"}]},{"title":"json 转换","slug":"json-转换","date":"2018-07-16T04:00:51.000Z","updated":"2018-07-16T04:11:27.809Z","comments":true,"path":"2018/07/16/json-转换/","link":"","permalink":"http://paris-jee.github.io/2018/07/16/json-转换/","excerpt":"","text":"jsonJSON字符串转化成对象解析 1、定义：是指将符合 JSON 语法规则的字符串转换成对象的过程。 2、不同的编程语言都提供了解析 JSON 字符串的方法，在这里主要讲解 JavaScript 中的解析方法。主要有三种： 1）- 使用 eval() 2）- 使用 JSON.parse() 3）- 使用第三方库，例如 JQuery 等 evaleval() 1、eval() 函数的参数是一个字符串，其作用是直接执行其中的 JavaScript 代码。 2、eval() 能够解析 JSON 字符串。从这里也可以看得出，JSON 和 JavaScript 是高度嵌合的。 3、但是，现在已经很少直接使用 eval() 来解析了，如果您的浏览器版本真的是很旧，可能才需要这个方法。此外，eval() 是一个相对危险的函数，因为字符串中可能含有未知因素。在这里，作为学习，还是要知道这也是一种方法。 4、请注意 eval() 的参数，在字符串两旁加了括号，这是必须的，否则会报错。 5、因为 JSON 字符串是被大括号（“{}”）包围的，直接放到 eval() 会被当成语句块来执行，因此要在两旁加上括号，使其变成表达式。1234567&lt;script&gt;var str = “console.log(‘hello’)”;eval(sre);&lt;/script&gt; JSON.parse()123456789&lt;script&gt;var str = ‘&#123; “name” : “Geoff Lui”,“age” : 26&#125;’; //符合JSON语法规则的字符串var obj = JSON.parse(str);console.log(obj);&lt;/script&gt; 如果输入了不符合规范的字符串，会报错 JSON.parse() 可以有第二个参数，是一个函数。此函数有两个参数：name 和 value，分别代表名称和值。当传入一个 JSON 字符串后，JSON 的每一组名称/值对都要调用此函数。该函数有返回值，返回值将赋值给当前的名称（name）。 利用第二个参数，可以在解析 JSON 字符串的同时对数据进行一些处理。 JSON对象转化为字符串序列化定义 指将 JavaScript 值转化为 JSON 字符串的过程。 JSON.stringify() 能够将 JavaScript 值转换成 JSON 字符串。JSON.stringify() 生成的字符串可以用 JSON.parse() 再还原成 JavaScript 值。 参数的含义 1）JSON.stringify(value[, replacer[, space]]) 2）value：必选参数。被变换的 JavaScript 值，一般是对象或数组。 3）replacer：可以省略。有两种选择：函数或数组。 ①- 如果是函数，则每一组名称/值对都会调用此函数，该函数返回一个值，作为名称的值变换到结果字符串中，如果返回 undefined，则该成员被忽略。 ②-如果是数组，则只有数组中存在名称才能够被转换，且转换后顺序与数组中的值保持一致。 4）space：可以省略。这是为了排版、方便阅读而存在的。可以在 JSON 字符串中添加空白或制表符等。1234567891011121314151617&lt;script&gt;var obj = &#123;name : “Geoff Lui”,age : 26&#125;;console.log(obj);var jsonstr = JSON.stringify(obj);console.log(jsonstr);&lt;/script&gt; replacer 的用法123456789101112131415161718192021222324252627&lt;script&gt;var obj = &#123;name : “Geoff Lui”,age : 26&#125;;console.log(obj);var jsonstr = JSON.stringify(obj,fun);function fun(name, value)&#123;If (name == “age” )value = 14;return value;&#125;console.log(jsonstr);&lt;/script&gt; 123456789101112131415161718192021&lt;script&gt;var obj = &#123;a : 1,b : 2,c : 3,d :4&#125;;console.log(obj);var jsonstr = JSON.stringify(obj,[“a”,”b”,”c”]);console.log(jsonstr);&lt;/script&gt; space 的用法 //排列的更加可读123456789101112131415161718192021&lt;script&gt;var obj = &#123;a : 1,b : 2,c : 3,d :4&#125;;console.log(obj);var jsonstr = JSON.stringify(obj,[“a”,”b”,”c”], “one”);console.log(jsonstr);&lt;/script&gt;","categories":[],"tags":[{"name":"JSON","slug":"JSON","permalink":"http://paris-jee.github.io/tags/JSON/"}]},{"title":"json 语法","slug":"json-语法","date":"2018-07-16T03:53:09.000Z","updated":"2018-07-16T04:01:08.141Z","comments":true,"path":"2018/07/16/json-语法/","link":"","permalink":"http://paris-jee.github.io/2018/07/16/json-语法/","excerpt":"","text":"json 语法1）- 数组（Array）用方括号(“[]”)表示。 2）- 对象（Object）用大括号（”{}”）表示。 3）- 名称/值对（name/value）之间用冒号（”：”）隔开。 4）- 名称（name）置于双引号中，值（value）有字符串、数值、布尔值、null、对象和数组。 5）- 并列的数据之间用逗号（“,”）分隔 对象1、对象用大括号（“{}”）括起来，大括号里是一系列的“名称/值对” 2、两个并列的数据之间用逗号（“,”）隔开，注意两点： 1）- 使用英文的逗号（“,”），不要用中文的逗号（“，”） 2）- 最后一个“名称/值对“之后不要加逗号 12345&#123;“name”:”Lucy”, //值必须用双引号“age”: 25&#125; 数组数组表示一系列有序的值，用方括号（“[]”）包围起来，并列的值之间用逗号分隔1[1,2,[1,2],&#123;“aa”:1&#125;] 名称/值对（Name/Value）1、名称（Name）是一个字符串，要用双引号括起来，不能用单引号，也不能没有引号，这一点与 JavaScript 不同。 2、值的类型只有七种：字符串（string）、数值（number）、对象（object）、数组（array）、true、false、null。不能有这之外的类型，例如 undefined、函数等。请看概念图。 3、字符串（string）的规则如下： 1）- 英文双引号括起来，不能用单引号，也不能没有。 2）- 字符串中不能单独出现双引号（”） 和右斜杠（“\\”）。 3）- 如果要打双引号或右斜杠，需要使用“右斜杠+字符”的形式，例如 \\” 和 \\，其它的转义字符也是如此 12345 &#123;“string”: ”one two” //字符串中间不可以加双引号，一定要用的时候，用转义字符“\\”&#125;","categories":[],"tags":[{"name":"JSON","slug":"JSON","permalink":"http://paris-jee.github.io/tags/JSON/"}]},{"title":"JSON","slug":"JSON","date":"2018-07-16T03:25:53.000Z","updated":"2018-07-16T03:47:36.859Z","comments":true,"path":"2018/07/16/JSON/","link":"","permalink":"http://paris-jee.github.io/2018/07/16/JSON/","excerpt":"","text":"JSON JSON，全称是 JavaScript Object Notation，即 JavaScript 对象标记法。 JSON 是一种轻量级（Light-Weight）、基于文本的（Text-Based）、可读的（Human-Readable）格式。 JSON 的名称中虽然带有 JavaScript，但这是指其语法规则是参考 JavaScript 对象的，而不是指只能用于 JavaScript 语言。 JSON 无论对于人，还是对于机器来说，都是十分便于阅读和书写的，而且相比 XML （另一种常见的数据交换格式），文件更小，因此迅速成为网络上十分流行的交换格式。 json 语法规则1）- 数组（Array）用方括号(“[]”)表示。 2）- 对象（Object）用大括号（”{}”）表示。 3）- 名称/值对（name/value）组合成数组和对象。 4）- 名称（name）置于双引号中，值（value）有字符串、数值、布尔值、null、对象和数组。名称/值对（name/value）之间用冒号（”：”）隔开。 5）- 并列的数据之间用逗号（“,”）分隔 实例 { “name”: “Geoff Lui”, “age”: 26 } json &amp; xmlJSON 常被拿来与 XML 做比较，因为 JSON 的诞生本来就多多少少要有取代 XML 的意思。相比 XML，JSON 的优势如下： 1）- 没有结束标签，长度更短，读写更快 2）- 能够直接被 JavaScript 解释器解析 3）- 可以使用数组 对比JSON和XML，比较相同与相异之处 json123456789&#123;&quot;name&quot;: &quot;parisjee&quot;,&quot;age&quot;: 23,&quot;friends&quot;: [&quot;Lily&quot;, &quot;Lucy&quot;, &quot;zero&quot;]&#125; xml12345678910111213141516&lt;root&gt;&lt;name&gt;parisjee&lt;/name&gt;&lt;age&gt;23&lt;/age&gt;&lt;friends&gt;Lily&lt;/friends&gt;&lt;friends&gt;Lucy&lt;/friends&gt;&lt;friends&gt;zero&lt;/friends&gt;&lt;/root&gt;``` ## json 解析与生成 在 JavaScript 中，有两个方法与此相关： **JSON.parse** 和 **JSON.stringify** 。 var str = ‘{“name”: “Geoff Lui”,”age”: 26,}’; var obj = ISON.parse(str); console.log(obj); var jsonstr = ISON.stringify(obj); console.log(jsonstr); `","categories":[{"name":"JSON","slug":"JSON","permalink":"http://paris-jee.github.io/categories/JSON/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"http://paris-jee.github.io/tags/JSON/"}]},{"title":"常量","slug":"常量","date":"2018-07-04T22:59:19.000Z","updated":"2018-07-04T23:23:30.849Z","comments":true,"path":"2018/07/05/常量/","link":"","permalink":"http://paris-jee.github.io/2018/07/05/常量/","excerpt":"","text":"常量常量也是一个简单值的标识符，正好和变量相反，在脚本执行期间这个值不能改变，也就是我们常量的值一经定义是不能对它进行重新赋值，这就是常量。 系统常量 自定义常量 魔术常量 1.常量的名称前面是没有这个$符号的2.我们的常量名称呢同样也是以字母或者下划线开始，尽量使用大写字母。3.常量可以在任何地方定义和使用。4.还有就是需要注意的就是常量一经定义不能改变。也不能取消这个定义。5.我们常量的值只能是标量，虽然说也可以使用我们的资源，但是呢我们尽量的不要去使用这个资源，更常用的呢我们常量的值用标量作为我们的值。像我们的整型、浮点类型、布尔类型，包括我们的字符串类型可以当做我们的常量的值。6.常量默认是不区分大小写的，如果需要区分大小写通过给define函数的第三个参数为true实现。 define函数定义常量constant($name)来得到这个常量的值defined(‘TEST‘)，返回值真或假PHP5.3.0以后了我们还可以通过const来定义一个常量，那之前呢const可以在类里面来定义常量，那在我们5.3.0之后呢可以使用const在类定义之外定义","categories":[],"tags":[{"name":"PHP 常量","slug":"PHP-常量","permalink":"http://paris-jee.github.io/tags/PHP-常量/"}]},{"title":"php变量","slug":"PHP变量","date":"2018-07-04T22:18:13.000Z","updated":"2018-07-04T23:22:50.524Z","comments":true,"path":"2018/07/05/PHP变量/","link":"","permalink":"http://paris-jee.github.io/2018/07/05/PHP变量/","excerpt":"","text":"变量在程序执行期间，可以变化的量。 声明变量：在php中是以$符加上变量名称 如 $a变量的名称以字母或者下划线开始，后面呢可以跟上数字、字母、下划线，这样的形式。不要包含特殊字符，什么是特殊字符呢？空格啊、叹号、*号啊、问号啊这样的都是我们的特殊字符 变量名称，严格区分大小写，什么意思呢，$a 和 $A 这是两个变量当变量名称重复的时候，相当于变量重新赋值了，后面的会覆盖之前的值php是弱类型语言,像Java，c 变量一定要声明之后才能使用，而弱类型语言比较松散，变量可以不用声明直接使用 可变变量 123456&lt;?php //可变变量的例子 $a=&apos;b&apos;; $b=&apos;c&apos;; $c=&apos;d&apos;; echo $$$a; 引用赋值 销毁变量函数unset($var):注销变量","categories":[{"name":"PHP","slug":"PHP","permalink":"http://paris-jee.github.io/categories/PHP/"}],"tags":[{"name":"PHP 变量","slug":"PHP-变量","permalink":"http://paris-jee.github.io/tags/PHP-变量/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-06-10T09:00:29.178Z","updated":"2018-06-10T09:00:29.179Z","comments":true,"path":"2018/06/10/hello-world/","link":"","permalink":"http://paris-jee.github.io/2018/06/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"PHP","slug":"one","date":"2017-06-17T16:00:00.000Z","updated":"2018-07-01T04:16:16.982Z","comments":true,"path":"2017/06/18/one/","link":"","permalink":"http://paris-jee.github.io/2017/06/18/one/","excerpt":"PHPPHP最早是 personal home page 的缩写，现在改称为Hypertext Proprecessor,即超文本预处理语言。PHP代码可嵌入HTML代码中 Thread safe(线程安全)简称TS和 Non Thread Safe（非线程安全）TS执行时会进行安全检查，以防止有新的请求就启动新线程的CGI执行方式而耗尽系统资源。NTS在执行时不进行线程安全检查。 PHP的两种执行方式ISAPI 和FastCGI。 PHP代码必须定义在执行块中才能执行，PHP有多种定义PHP执行块的方法a. 标准标签&lt;?php//这里写代码?&gt;b. 短标签&lt;?//这里写代码?&gt;短标签可以在php.ini文件中设置 short_tag_on 来开启。LInux/unix 系统采用多进程的工作方式，Windows系统采用多线程的工作方式。","text":"PHPPHP最早是 personal home page 的缩写，现在改称为Hypertext Proprecessor,即超文本预处理语言。PHP代码可嵌入HTML代码中 Thread safe(线程安全)简称TS和 Non Thread Safe（非线程安全）TS执行时会进行安全检查，以防止有新的请求就启动新线程的CGI执行方式而耗尽系统资源。NTS在执行时不进行线程安全检查。 PHP的两种执行方式ISAPI 和FastCGI。 PHP代码必须定义在执行块中才能执行，PHP有多种定义PHP执行块的方法a. 标准标签&lt;?php//这里写代码?&gt;b. 短标签&lt;?//这里写代码?&gt;短标签可以在php.ini文件中设置 short_tag_on 来开启。LInux/unix 系统采用多进程的工作方式，Windows系统采用多线程的工作方式。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://paris-jee.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://paris-jee.github.io/tags/PHP/"},{"name":"基本概念","slug":"基本概念","permalink":"http://paris-jee.github.io/tags/基本概念/"}]}]}