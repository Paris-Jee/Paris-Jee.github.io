{"meta":{"title":"纪国锐","subtitle":null,"description":null,"author":"Paris Jee","url":"http://paris-jee.github.io"},"pages":[{"title":"about","date":"2018-06-26T08:14:11.000Z","updated":"2018-06-26T08:14:11.222Z","comments":true,"path":"about/index.html","permalink":"http://paris-jee.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Ajax","slug":"Ajax","date":"2018-07-24T05:47:50.000Z","updated":"2018-07-25T23:24:35.281Z","comments":true,"path":"2018/07/24/Ajax/","link":"","permalink":"http://paris-jee.github.io/2018/07/24/Ajax/","excerpt":"","text":"Ajax Ajax的全称是Asynchronous JavaScript and XML,中文定义为”异步JavaScript和XML”，Web2.0技术的核心.由多种技术组合而成。使用Ajax技术不必刷新整个页面，只需对页面的局部进行更新，可以节省网络带宽，提高网页加载速度，从而缩短用户等待时间，改善用户体验。 Ajax的工作原理 Ajax，它是多种技术的组合包括我们的：JavaScript；异步数据获取技术（也就是ajax的核心：XMLHttpRequest）；数据交换和操作技术XML；动态显示和交互技术DOM；及其标准的表现技术XHTML和CSS。 XMLHttpRequest对象在IE浏览器中首次引入，它是一种支持异步请求的技术,也就是说我们的这个对象使我们可以用JavaScript向服务器提出请求，并处理响应。并且，它不阻塞用户，可以使我们的网络应用程序更加强大。 但是这个XMLHttpRequest对象其实是JavaScript的一个API,它支持浏览器发送Http POST或者是GET请求，该API是大多数Ajax交互的核心，也是现在Web开发的一项基本技术。通过ajax应用程序，无须重新加载网页，就可以发送并且取回数据。这项工作，需要通过向服务器发送HTTP 请求，这是在浏览器后端的，并通过服务器返回数据时，使用JavaScript仅仅修改网页的某部分。 优缺点可以和XHTML无缝继承。轻量、无须插件。 因为它是一个JavaScript的API，所以它依赖JavaScript，影响浏览器默认行为。 传统的HTML应用必须使用一个网页表单，向服务器GET或者POST数据。用户需要等待服务器的响应，然后一张新的网页会加到结果。 ajax会利用JavaScript的API直接与服务器通信，通过使用HTTP协议，web页面可以向服务器进行请求，并得到来自服务器的响应，但是不加载页面。用户可以停在同一页面，用户不会注意到脚本在后台请求过页面或者向服务器发送过数据。 我们ajax的技术核心是异步数据获取技术，也就是我们的XMLHttpRequest对象。 创建XMLHttpRequest这个对象1): 针对Firefox，opera以及Safari等高级浏览器,可以使用构造函数的方式:request = new XMLHttpRequest()2): xmlhttp = new ActiveXObject(‘Msxml2.XMLHTTP’)3): xmlhttp = new ActiveXObject(‘Microsoft.XMLHTTP’)","categories":[{"name":"ajax","slug":"ajax","permalink":"http://paris-jee.github.io/categories/ajax/"}],"tags":[{"name":"ajax php","slug":"ajax-php","permalink":"http://paris-jee.github.io/tags/ajax-php/"}]},{"title":"MVVC","slug":"MVC","date":"2018-07-23T23:37:09.000Z","updated":"2018-07-27T10:15:27.860Z","comments":true,"path":"2018/07/24/MVC/","link":"","permalink":"http://paris-jee.github.io/2018/07/24/MVC/","excerpt":"","text":"MVC全名是Model View Controller，是模型(model)-视图(view)-控制器(controller)的缩写，是一种开发模式，使程序的数据，视图和业务逻辑处理互相分离。 mvc是一种开发模式,主要分为三部分:m(model),也就是模型,负责数据的操作;v(view),也就是视图,负责前后台的显示;c(controller),也就是控制器,负责业务逻辑客户端请求项目的控制器,如果执行过程中需要用到数据,控制器就会到模型中获取数据,再将获取到的数据通过视图显示出来 模型层负责数据的流转，存入流出，控制器负责数据的业务逻辑处理，即响应视图输入的数据，给模型层，同时将模型层输出的数据处理后，交给视图层呈现。","categories":[],"tags":[]},{"title":"面向对象","slug":"面向对象","date":"2018-07-23T23:36:31.000Z","updated":"2018-07-24T00:09:54.788Z","comments":true,"path":"2018/07/24/面向对象/","link":"","permalink":"http://paris-jee.github.io/2018/07/24/面向对象/","excerpt":"","text":"面向对象我们所说的面向对象实际就是一种更高级，更抽象的思维方式。面向对象不仅仅只是PHP的，PHP也不是纯面向对象的。面向对象是不区分语言的，它在很多语言里面都有这种思想。Java和C++就是一种纯面向对象编写的一种语言。PHP只是模仿这些语言的面向对象编程，但是你也可以通过PHP写出面向对象的一些程序。 OOA（Object Oriented Analysis）：面向对象分析； OOD（Object Oriented Design）：面向对象设计； OOP（Object Oriented Programing）：面向对象编程。 面向过程与面向对象的区别面向过程编程相比于面向对象编程有什么缺点？1.代码杂乱无章，严格按照过程执行；2.代码复用性太差，难以扩展；3.开发效率较低；4.维护起来非常困难。面向对象编程可以提高代码的复用性，灵活性和扩展性。 面向对象的三大特性就是：封装，继承，多态。 类和对象 对象：一切事物皆对象，对象是系统中用来描述客观事物的一个实体，是构成系统的最基本的组成单位。 类：类是把具有相似特性的对象归纳到一个类中，类就是一组相同属性和行为的对象的集合。 类和对象的关系如下：1）类是相似对象的描述，类就是对象的一个蓝图，它只是一个模板，却暂时没有被实现；2）先有类，再有对象；3）类是对象的抽象；4）对象是类的实例。 构造函数和析构函数php封装性及访问控制 封装封装就是将类的成员封装起来，不让外界可以随意的访问和读取（内部的访问是不可以限制的，就是不管你的访问修饰符是什么，该类的其它成员方法都是可以访问这个成员的）1.public公有的，如果访问控制没有被明确说明（成员声明的时候前面没有加访问修饰符），默认则是公有的，这样的话可以在类的外部也可以被访问。2.protected受保护的，在类的内部访问，类的外部不可以访问。也可以在子类中被访问3.private私有的，只能在类的内部访问","categories":[],"tags":[{"name":"-面向对象","slug":"面向对象","permalink":"http://paris-jee.github.io/tags/面向对象/"}]},{"title":"php函数","slug":"php函数","date":"2018-07-23T08:43:47.000Z","updated":"2018-07-23T08:43:47.516Z","comments":true,"path":"2018/07/23/php函数/","link":"","permalink":"http://paris-jee.github.io/2018/07/23/php函数/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"mysql进阶","slug":"mysql进阶","date":"2018-07-23T08:43:09.000Z","updated":"2018-07-23T08:43:09.533Z","comments":true,"path":"2018/07/23/mysql进阶/","link":"","permalink":"http://paris-jee.github.io/2018/07/23/mysql进阶/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"sql语句","slug":"sql语句","date":"2018-07-23T08:42:41.000Z","updated":"2018-07-23T10:15:35.329Z","comments":true,"path":"2018/07/23/sql语句/","link":"","permalink":"http://paris-jee.github.io/2018/07/23/sql语句/","excerpt":"","text":"SQL语句 SQL 是一种为数不多的声明性语言，它的运行方式完全不同于我们所熟知的命令行语言、面向对象的程序语言、甚至是函数语言（尽管有些人认为 SQL 语言也是一种函数式语言）SQL 语句的语法顺序和其执行顺序并不一致 创建一个数据库使用 create database 语句可完成对数据库的创建, 创建命令的格式如下: create database 数据库名 [其他选项];例如我们需要创建一个名为 samp_db 的数据库, 在命令行下执行以下命令: create database samp_db character set gbk;为了便于在命令提示符下显示中文, 在创建时通过 character set gbk 将数据库字符编码指定为 gbk。创建成功时会得到 Query OK, 1 row affected(0.02 sec) 的响应。注意: MySQL语句以分号(;)作为语句的结束, 若在语句结尾不添加分号时, 命令提示符会以 -&gt; 提示你继续输入(有个别特例, 但加分号是一定不会错的); 可以使用 show databases; 命令查看已经创建了哪些数据库。 选择所要操作的数据库要对一个数据库进行操作, 必须先选择该数据库, 否则会提示错误:ERROR 1046(3D000): No database selected命令: use 数据库名; 创建数据库表使用 create table 语句可完成对表的创建, create table 的常见形式:create table 表名称(列声明);以创建 students 表为例, 表中将存放 学号(id)、姓名(name)、性别(sex)、年龄(age)、联系电话(tel) 这些内容: create table students（id int unsigned not null auto_increment primary key,name char(8) not null,sex char(4) not null,age tinyint unsigned not null,tel char(13) null default “-“); 向表中插入数据insert 语句可以用来将一行或多行数据插到数据库表中, 使用的一般形式如下:insert [into] 表名 [(列名1, 列名2, 列名3, ...)] values (值1, 值2, 值3, ...);有时我们只需要插入部分数据, 或者不按照列的顺序进行插入, 可以使用这样的形式进行插入:insert into students (name, sex, age) values(“孙丽华”, “女”, 21); 查询表中的数据select 语句常用来根据一定的查询规则到数据库中获取数据, 其基本的用法为:select 列名称 from 表名称 [查询条件];例如要查询 students 表中所有学生的名字和年龄, 输入语句select name, age from students; 更新表中的数据update 语句可用来修改表中的数据, 基本的使用形式为:update 表名称 set 列名称=新值 where 更新条件;example:将 id 为 5 的手机号改为默认的”-“:update students set tel=default where id=5 ;将所有人的年龄增加 1:update students set age=age+1;将手机号为 13288097888 的姓名改为 “张伟鹏”, 年龄改为 19:update students set name=”张伟鹏”, age=19 where tel=”13288097888” ; 删除表中的数据delete 语句用于删除表中的数据, 基本用法为:delete from 表名称 where 删除条件;example:删除 id 为 2 的行:delete from students where id=2 ;删除所有年龄小于 21 岁的数据:delete from students where age&lt;20 ;删除表中的所有数据: delete from students ; alter table 语句用于创建后对表的修改, 基础用法如下 添加列基本形式: alter table 表名 add 列名 列数据类型 [after 插入位置] ;example:在表的最后追加列 address:alter table students add address char(60) ;在名为 age 的列后插入列 birthday:alter table students add birthday date after age ; 修改列基本形式: alter table 表名 change 列名称 列新名称 新数据类型 ;示例:将表 tel 列改名为 telphone:alter table students change tel telphone char(13) default “-“ ;将 name 列的数据类型改为 char(16):alter table students change name name char(16) not null ; 删除列基本形式: alter table 表名 drop 列名称 ;示例:删除 birthday 列: alter table students drop birthday ; 重命名表基本形式: alter table 表名 rename 新表名 ;示例:重命名 students 表为 workmates:alter table students rename workmates ;5.删除整张表基本形式: drop table 表名 ;示例:删除 workmates 表:drop table workmates ; 删除整个数据库基本形式: drop database 数据库名 ;示例:删除 samp_db 数据库: drop database samp_db ;","categories":[{"name":"数据库","slug":"数据库","permalink":"http://paris-jee.github.io/categories/数据库/"}],"tags":[{"name":"-数据库 -MySQL","slug":"数据库-MySQL","permalink":"http://paris-jee.github.io/tags/数据库-MySQL/"}]},{"title":"mysql基础","slug":"mysql基础","date":"2018-07-23T08:42:14.000Z","updated":"2018-07-27T10:27:39.426Z","comments":true,"path":"2018/07/23/mysql基础/","link":"","permalink":"http://paris-jee.github.io/2018/07/23/mysql基础/","excerpt":"","text":"mysql基础","categories":[{"name":"mysql","slug":"mysql","permalink":"http://paris-jee.github.io/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://paris-jee.github.io/tags/mysql/"}]},{"title":"thinkphp3.2 & thinkphp5","slug":"thinkphp","date":"2018-07-23T08:41:36.000Z","updated":"2018-07-23T08:41:36.123Z","comments":true,"path":"2018/07/23/thinkphp/","link":"","permalink":"http://paris-jee.github.io/2018/07/23/thinkphp/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Composer","slug":"Composer","date":"2018-07-23T08:40:47.000Z","updated":"2018-07-27T10:24:23.961Z","comments":true,"path":"2018/07/23/Composer/","link":"","permalink":"http://paris-jee.github.io/2018/07/23/Composer/","excerpt":"","text":"Composer PHP 用来管理依赖（dependency）关系的工具。你可以在自己的项目中声明所依赖的外部工具库（libraries），Composer 会帮你安装这些依赖的库文件。 拓展和包是两个非常相近的概念。在PHP世界里，一般可以这样理解和区分两者：拓展（extension）和模块（module）等价，是用C语言写的功能合集；包(package)和库（library）等价，主要是用PHP实现的功能合集；拓展以动态链接库（dll或so）的形式加载，包则是通过require/include方式加载。绝大部分时候，两者混用不会造成理解上的困难。常见的拓展包括GD、ZIP、XML、MySQLi、OPCache等，常见的包包括PHPMailer、PHPOffice、HTMLPurifier等。 PEAR和PECL在Composer流行之前，PEAR和PECL是更为PHP开发者所知的两个工具（社区）。PEAR是PHP拓展和应用仓库（PHP Extension and Application Repository）的缩写，官网http://pear.php.net ；PECL是PHP拓展社区库（PHP Extension Community Library）的缩写，官网http://pecl.php.net。两者的区别可用拓展和包来区分：PECL托管拓展，源代码多为C文件，例如APC、AMPQ等；PEAR托管包，功能用PHP实现，如PHP CodeSniffer、HTTP Request等；PEAR对应pear命令，PECL对应pecl命令，可用这两个命令安装和管理拓展和包（pear的build/pickle子命令也可以编译PECL中的拓展）。两者互为补充，官网以姐妹（sisters）形容两者的关系。PECL是官方拓展的补充，目前仍处于活跃状态，一些优秀的拓展有成为官方拓展的潜质。韩天峰大神的swoole拓展也托管在PECL中，国内名气非常高。相比之下PEAR已是明日黄花。PEAR2和Pyrus（下一代的PEAR包安装工具，基于PHP5.3+构建，官网http://pear2.php.net）的出现也未能挽救PEAR。PEAR没落伴随着本文主角Composer的兴起。PEAR的定位是“提供可复用的PHP组件”，以中心化的方式为开发者提供功能包。中心化发布的方式保证了代码的质量，同时带来维护上的不便：通过评审的包才能发布，包过时现象严重。PEAR安装的包是全局的，不能为单独项目安装依赖包，非特权用户不能自行安装依赖包。其他缺点还包括糟糕的依赖管理。随着Github的流行和Composer的出现，包管理进入Composer时代。PEAR已经完成其历史使命，可以安心的去了。","categories":[{"name":"php","slug":"php","permalink":"http://paris-jee.github.io/categories/php/"}],"tags":[{"name":"php Composer","slug":"php-Composer","permalink":"http://paris-jee.github.io/tags/php-Composer/"}]},{"title":"git命令","slug":"git命令","date":"2018-07-23T08:39:52.000Z","updated":"2018-07-23T10:25:32.608Z","comments":true,"path":"2018/07/23/git命令/","link":"","permalink":"http://paris-jee.github.io/2018/07/23/git命令/","excerpt":"","text":"Git命令 Git是一个由林纳斯·托瓦兹为了更好地管理linux内核开发而创立的分布式版本控制／软件配置管理软件。需要注意的是和GNU Interactive Tools，一个类似Norton Commander界面的文件管理器相区分 当安装完Git应该做的第一件事就是设置你的用户名称与邮件地址。 这样做很重要，因为每一个Git的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改 git config –global user.name “paris”git config –global user.email “paris@example.com“ 再次强调，如果使用了 –global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 –global 选项的命令来配置 git init 初始化仓库git add 添加文件到暂存区git commit 提交文件到仓库git diff 比对本地和版本库里面的文件git log 查看历史提交记录 初始化一个Git仓库，使用git init命令。第一步，使用命令git add .,添加全部 ，注意，可反复多次使用，添加多个文件；第二步，使用命令git commit -m “提交的注释”，完成。 第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 在修改了文件之后，且还没有add之前，可执行以下命令丢弃工作区的修改。$ git checkout –- readme.txtgit checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令 如果你想要修改，已经git add到暂存区，但还没有commit的内容。我们可以用命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区：$ git reset HEAD readme.txt git init //初始化本地仓库git add //添加文件git status //查看状态git commit //提交git push //推送到仓库git pull //从远程仓库拉取数据git clone //从远程仓库拷贝数据 git 操作touch .gitignore 创建git忽略文件，在其中写入要忽略的文件。忽略文件夹请使用文件夹名称git branch login 创建分支git checkout login 切换分支touch login.htmlgit add . 上传到当前分支git remote add origin 远程仓库地址git remote 检查连接git push -u origin master 上传","categories":[{"name":"git","slug":"git","permalink":"http://paris-jee.github.io/categories/git/"}],"tags":[{"name":"-git -命令","slug":"git-命令","permalink":"http://paris-jee.github.io/tags/git-命令/"}]},{"title":"php设计模式","slug":"php设计模式","date":"2018-07-23T08:39:17.000Z","updated":"2018-07-23T09:26:50.959Z","comments":true,"path":"2018/07/23/php设计模式/","link":"","permalink":"http://paris-jee.github.io/2018/07/23/php设计模式/","excerpt":"","text":"php设计模式设计模式是面向对象编程的经验总结和最佳实践 Descriptions of communicating objects and classes that are customized to solve a general design problem in a particular context.翻译就是说为解决特定上下文中的一般设计问题而定制的通信对象和类的说明。通俗的说，设计模式是一种编码规则，是从宏观上思考为实现特定功能或者系统而设计的代码组织方式。就像一群人完成某一项工作，不能一窝蜂全上，需要有组织有纪律，这个组织和纪律就是设计模式的概念。 作用：灵活正确的使用设计模式，能够让系统的开发速度快，代码复用性高，容易维护，扩展性强，并且利于团队协作。 类别 创建型在软件工程中，创建型设计模式是处理对象创建机制的设计模式，试图以适当的方式来创建对象。对象创建的基本形式可能会带来设计问题，亦或增加了设计的复杂度。创建型设计模式通过控制这个对象的创建方式来解决此问题。 抽象工厂模式（Abstract Factory） 建造者模式（Builder） 工厂方法模式（Factory Method） 多例模式（Multiton） 对象池模式（Pool） 原型模式（Prototype） 简单工厂模式（Simple Factory） 单例模式（Singleton） 静态工厂模式（Static Factory） 结构型在软件工程中，结构型设计模式是通过识别实体之间关系来简化设计的设计模式。 适配器模式（Adapter） 桥梁模式（Bridge） 组合模式（Composite） 数据映射模式（Data Mapper） 装饰模式（Decorator） 依赖注入模式（Dependency Injection） 门面模式（Facade） 流接口模式（Fluent Interface） 享元模式（Flyweight） 代理模式（Proxy） 注册模式（Registry） 行为型在软件工程中，行为设计模式是识别对象之间的通用通信模式并实现这些模式的设计模式。 通过这样做，这些模式增加了执行此通信的灵活性。 责任链模式（Chain Of Responsibilities） 命令行模式（Command） 迭代器模式（Iterator） 中介者模式（Mediator） 备忘录模式（Memento） 空对象模式（Null Object） 观察者模式（Observer） 规格模式（Specification） 状态模式（State） 策略模式（Strategy） 模板方法模式（Template Method） 访问者模式（Visitor） 其他类型 委托模式（Delegation） 服务定位器模式（Service Locator） 资源库模式（Repository） 实体属性值模式（EAV 模式）","categories":[{"name":"PHP","slug":"PHP","permalink":"http://paris-jee.github.io/categories/PHP/"}],"tags":[{"name":"-PHP -设计模式","slug":"PHP-设计模式","permalink":"http://paris-jee.github.io/tags/PHP-设计模式/"}]},{"title":"TCP/IP","slug":"TCP IP","date":"2018-07-22T11:28:52.000Z","updated":"2018-07-22T15:07:57.243Z","comments":true,"path":"2018/07/22/TCP IP/","link":"","permalink":"http://paris-jee.github.io/2018/07/22/TCP IP/","excerpt":"","text":"TCP/IP TCP/IP（Transmission Control Protocol/Internet Protocol）是传输控制协议和网络协议的简称，它定义了电子设备如何连入因特网，以及数据如何在它们之间传输的标准。 TCP/IP 不是一个协议，而是一个协议族的统称，里面包括了 IP 协议、ICMP 协议、TCP 协议、以及 http、ftp、pop3、https 协议等。网络中的计算机都采用这套协议族进行互联。 什么是TCP/IP模型？TCP/IP模型是一系列网络协议的总称，这些协议的目的，就是使计算机之间可以进行信息交换。所谓”协议”可以理解成机器之间交谈的语言，每一种协议都有自己的目的。TCP/IP模型一共包括几百种协议，对互联网上交换信息的各个方面都做了规定。 TCP/IP模型的四层结构 连接层（Link Layer）负责建立电路连接，是整个网络的物理基础，典型的协议包括以太网、ADSL等等 网络层（Internet Layer）负责分配地址和传送二进制数据，主要协议是IP协议,Ip协议和icmp协议。 传输层（Transport Layer）负责传送文本数据，主要协议是TCP协议,Tcp和udp协议。 应用层（Application Layer）负责传送各种最终形态的数据，是直接与用户打交道的层，典型协议是HTTP、FTP等. http超文本传输协议（这也是我们web应用传输的一个协议）；第二个是ftp协议（文件传输协议）；还有一种就是smtp（这是我们的简单邮件传输协议）。设计互联网的原始目的，就是为了传输文本。所有协议最初都是为了这个目标而设计的，互联网架构的核心就是文本对话。TCP协议特点：面向连接的一种协议，这个面向连接就能够保证数据准确无误的，不会发生数据丢失的一种情况。首先，这个A电脑发送一段数据到B电脑上，问这个B电脑在不在。如果这个B电脑能接收到这个数据，那么B电脑就会回一句话给A电脑（发一个数据过来），告诉A电脑：我在，你可以发数据过来。而这个A电脑接收了B电脑的数据过后，它还是再一次发送数据过去，告诉B电脑：我知道你在了，现在我们可以发数据了。那么，经过这三次发数据，它就能够保证数据准确无误传到B电脑上。这三次发数据其实就是我们平时所说的：三次握手。通过这三次握手，来保证不会发生数据丢包。UDP协议它的全称叫做：用户数据报协议。它的英文名叫做：user data protocol。特点：它就是更tcp恰好相反，它是面向无连接的一种协议。它不管对面到底在不在，它只管把这个数据包发出去。如果对面的电脑没在的话，它就把这个数据包丢掉。区别：tcp面向连接，能保证数据能够准确无误的传到对方电脑上；（但是它的传输效率相对于udp，就要低一些，因为它要经过几次握手）而这个udp的话，虽然说它的传输效率高，但是可能会发生数据丢包。","categories":[{"name":"协议","slug":"协议","permalink":"http://paris-jee.github.io/categories/协议/"}],"tags":[{"name":"-协议 -TCP/IP","slug":"协议-TCP-IP","permalink":"http://paris-jee.github.io/tags/协议-TCP-IP/"}]},{"title":"Linux 命令","slug":"Linux-命令","date":"2018-07-18T10:40:41.000Z","updated":"2018-07-18T11:15:26.477Z","comments":true,"path":"2018/07/18/Linux-命令/","link":"","permalink":"http://paris-jee.github.io/2018/07/18/Linux-命令/","excerpt":"","text":"Linux命令文件浏览命令格式： 命令 [option] file cat 由第一行开始显示文件内容 tac 从最后一行开始显示，tac 是 cat 的倒写 nl 显示行号 -b a ：空行也列出行号(类似 cat -n)； -b t ：非空行才列出行号(默认值)； more 一页一页的显示文件内容 [空格键]下一页，[Backspace]上一页。 +n 从笫n行开始显示 -n 定义屏幕大小为n行 -c 清屏显示 less 与 more 类似，但他可以往前翻页 [空格键] 滚动一行， [回车键] 滚动一页，[pagedown]： 下一页，[pageup]：上一页 head 看头几行， -n 设定行数 tail 看尾部几行 -f 循环读取 tail -100f catalina.out od 以二进制的方式读取文件内容 文件目录操作命令 mkdir -m：mode 设定权限 -p：parents 创建父级目录 mkdir -m 777 -p dir1/dir2 rm -r 递归 -f force 强行删除，忽略不存在的文件，系统不再提示 rm -rf dir mv -b ：覆盖前先备份 -f ：force 强制覆盖 -i ：询问是否覆盖 mv 1.txt 2.txt 可用于重命名 ls命令 列出目录中所有子目录和文件-a, –all 列出目录下的所有文件，包括以.开头的隐含文件-l 列出目录或文件的详细信息，包括文件的权限、所有者、文件大小等-R, –recursive 递归查询 -r, –reverse 依相反次序排列 -t 以文件修改时间排序-F 显示文件类型（File type），在列出的文件名后添加符号：/ 表明是一个目录；@ 表明是到其它文件的符号链接； 表明是一个可执行文件。ls -l s 列出当前目录中所有以“s”开头的目录的详细内容ls -F /opt/soft |grep /$ 只列出文件下的子目录ls -ltr s* 列出目录下以s 开头的档案，愈新的排愈后面ls | sed “s:^:pwd/:” 列出文件的绝对路径 tar 为linux的文件和目录创建档案tar [主选项+辅选项] 文件或目录主选项：【每条命令只能有一个主选项】-c: –create 新建一个压缩文档，即打包 -x: –extract,–get 解压文件t: –list 查看压缩文档里的所有内容 -r:–append 向压缩文档里追加文件 -u:–update 更新原压缩包中的文件辅助选项：-z 支持gzip解压文件-j 支持bzip2解压文件-Z 支持compress解压文件-v 显示操作过程-f 指定压缩文件-t 显示压缩文件的内容-d 记录文件的差别-W 确认压缩文件的正确性-l 文件系统边界设置-k 保留原有文件不覆盖-m 保留文件不被覆盖 tar -cvf log.tar 1.log 2.log 仅打包，不压缩！ tar -tf log.tar 不解压的情况下查看 gzip-a 使用ASCII文字模式 -d 解压文件 -l 列出压缩文件的详细信息 -r 递归处理 -v 显示指令执行过程-num 用指定的数字num调整压缩的速度，-1或–fast表示最快压缩方法（低压缩比），-9或–best表示最慢压缩方法（高压缩比）。系统缺省值为6。gzip / gzip -dv 压缩和解压缩文件或目录，若当前目录下有10个文件则生成10个.gz的压缩包，gzip没有打包功能文件查找命令 find命令 在目录结构中搜索文件格式：find pathname -options [-print -exec -ok …] which命令 查看可执行文件的位置 whereis命令 定位文件在文件系统中的位置 locate命令 配合数据库查看文件位置 文件权限设置命令 chmod命令权限分为只读r、只写w 和 可执行x，用户分为 文件所有者u、同组用户g、其他用户o 和 所有的用户及群组a1）文字设定法: chmod ［who］ ［+ | - | =］ ［mode］ 文件名2）数字设定法: chmod ［mode］ 文件名 数字属性的mode为3个数字，按顺序表示（u）（g）（o）对应的权限。r=4，w=2，x=1 ，- 为0 表示删除权限 rwx属性为4+2+1=7 ； rw-属性则4+2=6；r-x属性则4+1=5。 chmod ug+w,o-x test.log ; chmod -R 777 dir chgrp命令 （change group） 改变文件或目录所属的用户组 chown命令（change owner） 改变文件或目录的所有者和所属的用户组","categories":[{"name":"Linux","slug":"Linux","permalink":"http://paris-jee.github.io/categories/Linux/"}],"tags":[{"name":"-Linux命令","slug":"Linux命令","permalink":"http://paris-jee.github.io/tags/Linux命令/"}]},{"title":"Linux 文件系统","slug":"Linux-文件系统","date":"2018-07-17T02:35:18.000Z","updated":"2018-07-17T03:00:14.303Z","comments":true,"path":"2018/07/17/Linux-文件系统/","link":"","permalink":"http://paris-jee.github.io/2018/07/17/Linux-文件系统/","excerpt":"","text":"Linux 文件系统文件系统概述 文件系统是一种组织计算机文件和资料的方法； 操作系统中封装的系统服务程序，实际上是一个软件程序，用来存储和管理计算机文件和资料。 文件系统分类 磁盘文件系统：NTFS（Windows下），EXT3（linux下，基于日志）； 闪存文件系统（u盘）：JFFS2，YAFFS； 数据库文件系统：BFFS，WINFS； 网络文件系统：NFS； 虚拟文件系统：VFS（Proc）； 虚拟文件系统：在不同的文件系统，它的文件的定义和实现方式都不太一样，所以这些文件的移植性比较困难，虚拟文件系统针对不同的标准定义了一个标准的接口，也就是标准的实现方式，这些不同的标准接口，通过虚拟文件系统进行了一个处理，面向我们用户使用者来说，都是使用的同一个标准，由虚拟文件系统转换成具体的文件系统的方式。 文件系统功能 能定义文件的组织方式：文件结构； 提供建立和存取文件的环境：目录和文件； 能对文件存储器空间进行组织和分配； 负责文件存储并对存入的文件进行保护和检索； 负责建立文件，存入、读出、修改、转储文件，控制文件的存取，撤销文件等。 linux文件系统特点 EXT3是基于日志方式的文件系统；系统中每个文件都是有索引，用户对对文件的每一个操作都会记录日志，形成一个任务队列排着执行 （可以监控用户对文件系统的操作，比如：用户在进行操作的时候发生了什么错误，或者类似于崩溃这样的问题，它可以通过得到相应的记录从而进行很好地检修或更改修复，同时把用户的操作记录成日志后，它不会马上去执行，可以 形成一个任务队列排着一个一个执行）， 性能比较好。 swap是交换分区的文件系统，类似windows的虚拟内存虚拟内存的实现：两种方式。第一种是进行内存的排列像内存池一样，进行一个优化。第二种是把硬盘上的空间模拟成内存。swap是Linux的虚拟内存，在安装时要设好大小，是物理内存的2倍（安装红帽会进行设置）。 特点 Linux系统中一切皆文件Linux系统把设备(硬盘、软驱、光驱等)都看作文件，文件夹也看作文件（文件没有扩展名）。 Linux文件类型普通文件目录文件链接文件块设备字符设备Socket管道文件 Linux文件属性（不同的版本可能不同）蓝色：目录绿色：可执行浅蓝色：链接红色：压缩灰色：其他Pwd:可以看到当前目录### 根目录下的bin，这里有很多的可执行文件etc目录，这个是配置文件dev：设备目录 文件系统目录根目录下有很多子目录，不同的目录有不同的功能：var是存放变量，usr是用户的相关文件，有源文件，可执行文件，需要用到的包含文件，函数库和用户自己的程序等。linux操作系统区分大小写。 Linux与Windows目录结构的区别 根目录：Linux：/；Windows：\\ 命名大小写区分：Linux：命名区分大小写；Windows：命名不区分大小写 结构管理Linux：磁盘逻辑结构管理物理结构，格式化将磁盘分为很多的文件块区；Windows：物理结构管理逻结构，先分区再格式化建立结构。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://paris-jee.github.io/categories/Linux/"}],"tags":[{"name":"-Linux -文件系统","slug":"Linux-文件系统","permalink":"http://paris-jee.github.io/tags/Linux-文件系统/"}]},{"title":"Linux","slug":"Linux","date":"2018-07-17T02:24:37.000Z","updated":"2018-07-17T02:33:32.754Z","comments":true,"path":"2018/07/17/Linux/","link":"","permalink":"http://paris-jee.github.io/2018/07/17/Linux/","excerpt":"","text":"Linux一个linux组成至少有三个部分： kernel：内核，包围在硬件之上作用管理设备、进程、内存、交换空间、文件系统、精灵进程等；控制系统程序与硬件之间打交道的功能； shell：外壳，包裹在内核之上提供人机交互界面，用户与内核之间打交道的功能，类似Windows的cmd.分类：不同shell，命令解释不一样命令提示符：不同shell的命令提示符不一样sh,Bash（常用的shell）：#root(超级用户) $user（普通用户） //可以通过符号区分是超级用户还是普通用户csh：#root %userFileSystem：文件系统，管理文件、目录 Linux特性多用户，多任务（进程、线程处理），多平台（linux操作系统大部分代码都是由c语言来写的，c语言具有比较好的移植性，尤其是对于不同的硬件平台），图形化界面 （x-window）硬件支持（低配置），通信与联网，应用程序支持（编辑器、编程工具、数据库、办公软件、图形处理、Internet应用、游戏等）。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://paris-jee.github.io/categories/Linux/"}],"tags":[{"name":"-Linux","slug":"Linux","permalink":"http://paris-jee.github.io/tags/Linux/"}]},{"title":"HTTP 协议","slug":"HTTP-协议","date":"2018-07-17T01:54:55.000Z","updated":"2018-07-17T02:24:14.298Z","comments":true,"path":"2018/07/17/HTTP-协议/","link":"","permalink":"http://paris-jee.github.io/2018/07/17/HTTP-协议/","excerpt":"","text":"HTTP 协议1.简单来说http协议是一种无状态、B/S（浏览器和服务器）模式应用层协议，多基于TCP协议。2.http协议都包含什么内容？因为http协议它是一种浏览器、服务器模式的应用程序，那么它肯定包含请求也包含响应，这里我要了解的是请求里面包含些什么东西，和响应里面还包含什么东西请求里面报文的格式包括报头、正文、URI，然后还有请求方法和请求头等响应里面包括响应的状态码、消息报头还有响应正文 常见请求头 “user-aget”“cookle” “Referrer”常见响应头 ”Content-Type” “Content-Length” “Cache”常见状态码 状态码中的“2xx”表示请求是成功的或者是传出内容，“3xx”表示跳转，“4xx”表示客户端请求错误，“5xx”表示服务器端错误。 因为前面有提到http是一种无连接，无状态的一种协议，就是在两个请求之间，下一个请求是不知道上一个请求的状态的，所以为了解决这个问题就引入了“cookie”。 referer 就是跳转到当前的这个页面，我是从哪个页面来的，这个在做网站统计的时候是非常有用的东西，因为这个referer在浏览器的安全策略里面是不允许改的，就是别人是控制不了这个referer。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://paris-jee.github.io/categories/HTTP/"}],"tags":[{"name":"-HTTP协议","slug":"HTTP协议","permalink":"http://paris-jee.github.io/tags/HTTP协议/"}]},{"title":"json 转换","slug":"json-转换","date":"2018-07-16T04:00:51.000Z","updated":"2018-07-16T04:11:27.809Z","comments":true,"path":"2018/07/16/json-转换/","link":"","permalink":"http://paris-jee.github.io/2018/07/16/json-转换/","excerpt":"","text":"jsonJSON字符串转化成对象解析 1、定义：是指将符合 JSON 语法规则的字符串转换成对象的过程。 2、不同的编程语言都提供了解析 JSON 字符串的方法，在这里主要讲解 JavaScript 中的解析方法。主要有三种： 1）- 使用 eval() 2）- 使用 JSON.parse() 3）- 使用第三方库，例如 JQuery 等 evaleval() 1、eval() 函数的参数是一个字符串，其作用是直接执行其中的 JavaScript 代码。 2、eval() 能够解析 JSON 字符串。从这里也可以看得出，JSON 和 JavaScript 是高度嵌合的。 3、但是，现在已经很少直接使用 eval() 来解析了，如果您的浏览器版本真的是很旧，可能才需要这个方法。此外，eval() 是一个相对危险的函数，因为字符串中可能含有未知因素。在这里，作为学习，还是要知道这也是一种方法。 4、请注意 eval() 的参数，在字符串两旁加了括号，这是必须的，否则会报错。 5、因为 JSON 字符串是被大括号（“{}”）包围的，直接放到 eval() 会被当成语句块来执行，因此要在两旁加上括号，使其变成表达式。1234567&lt;script&gt;var str = “console.log(‘hello’)”;eval(sre);&lt;/script&gt; JSON.parse()123456789&lt;script&gt;var str = ‘&#123; “name” : “Geoff Lui”,“age” : 26&#125;’; //符合JSON语法规则的字符串var obj = JSON.parse(str);console.log(obj);&lt;/script&gt; 如果输入了不符合规范的字符串，会报错 JSON.parse() 可以有第二个参数，是一个函数。此函数有两个参数：name 和 value，分别代表名称和值。当传入一个 JSON 字符串后，JSON 的每一组名称/值对都要调用此函数。该函数有返回值，返回值将赋值给当前的名称（name）。 利用第二个参数，可以在解析 JSON 字符串的同时对数据进行一些处理。 JSON对象转化为字符串序列化定义 指将 JavaScript 值转化为 JSON 字符串的过程。 JSON.stringify() 能够将 JavaScript 值转换成 JSON 字符串。JSON.stringify() 生成的字符串可以用 JSON.parse() 再还原成 JavaScript 值。 参数的含义 1）JSON.stringify(value[, replacer[, space]]) 2）value：必选参数。被变换的 JavaScript 值，一般是对象或数组。 3）replacer：可以省略。有两种选择：函数或数组。 ①- 如果是函数，则每一组名称/值对都会调用此函数，该函数返回一个值，作为名称的值变换到结果字符串中，如果返回 undefined，则该成员被忽略。 ②-如果是数组，则只有数组中存在名称才能够被转换，且转换后顺序与数组中的值保持一致。 4）space：可以省略。这是为了排版、方便阅读而存在的。可以在 JSON 字符串中添加空白或制表符等。1234567891011121314151617&lt;script&gt;var obj = &#123;name : “Geoff Lui”,age : 26&#125;;console.log(obj);var jsonstr = JSON.stringify(obj);console.log(jsonstr);&lt;/script&gt; replacer 的用法123456789101112131415161718192021222324252627&lt;script&gt;var obj = &#123;name : “Geoff Lui”,age : 26&#125;;console.log(obj);var jsonstr = JSON.stringify(obj,fun);function fun(name, value)&#123;If (name == “age” )value = 14;return value;&#125;console.log(jsonstr);&lt;/script&gt; 123456789101112131415161718192021&lt;script&gt;var obj = &#123;a : 1,b : 2,c : 3,d :4&#125;;console.log(obj);var jsonstr = JSON.stringify(obj,[“a”,”b”,”c”]);console.log(jsonstr);&lt;/script&gt; space 的用法 //排列的更加可读123456789101112131415161718192021&lt;script&gt;var obj = &#123;a : 1,b : 2,c : 3,d :4&#125;;console.log(obj);var jsonstr = JSON.stringify(obj,[“a”,”b”,”c”], “one”);console.log(jsonstr);&lt;/script&gt;","categories":[],"tags":[{"name":"JSON","slug":"JSON","permalink":"http://paris-jee.github.io/tags/JSON/"}]},{"title":"json 语法","slug":"json-语法","date":"2018-07-16T03:53:09.000Z","updated":"2018-07-16T04:01:08.141Z","comments":true,"path":"2018/07/16/json-语法/","link":"","permalink":"http://paris-jee.github.io/2018/07/16/json-语法/","excerpt":"","text":"json 语法1）- 数组（Array）用方括号(“[]”)表示。 2）- 对象（Object）用大括号（”{}”）表示。 3）- 名称/值对（name/value）之间用冒号（”：”）隔开。 4）- 名称（name）置于双引号中，值（value）有字符串、数值、布尔值、null、对象和数组。 5）- 并列的数据之间用逗号（“,”）分隔 对象1、对象用大括号（“{}”）括起来，大括号里是一系列的“名称/值对” 2、两个并列的数据之间用逗号（“,”）隔开，注意两点： 1）- 使用英文的逗号（“,”），不要用中文的逗号（“，”） 2）- 最后一个“名称/值对“之后不要加逗号 12345&#123;“name”:”Lucy”, //值必须用双引号“age”: 25&#125; 数组数组表示一系列有序的值，用方括号（“[]”）包围起来，并列的值之间用逗号分隔1[1,2,[1,2],&#123;“aa”:1&#125;] 名称/值对（Name/Value）1、名称（Name）是一个字符串，要用双引号括起来，不能用单引号，也不能没有引号，这一点与 JavaScript 不同。 2、值的类型只有七种：字符串（string）、数值（number）、对象（object）、数组（array）、true、false、null。不能有这之外的类型，例如 undefined、函数等。请看概念图。 3、字符串（string）的规则如下： 1）- 英文双引号括起来，不能用单引号，也不能没有。 2）- 字符串中不能单独出现双引号（”） 和右斜杠（“\\”）。 3）- 如果要打双引号或右斜杠，需要使用“右斜杠+字符”的形式，例如 \\” 和 \\，其它的转义字符也是如此 12345 &#123;“string”: ”one two” //字符串中间不可以加双引号，一定要用的时候，用转义字符“\\”&#125;","categories":[],"tags":[{"name":"JSON","slug":"JSON","permalink":"http://paris-jee.github.io/tags/JSON/"}]},{"title":"JSON","slug":"JSON","date":"2018-07-16T03:25:53.000Z","updated":"2018-07-16T03:47:36.859Z","comments":true,"path":"2018/07/16/JSON/","link":"","permalink":"http://paris-jee.github.io/2018/07/16/JSON/","excerpt":"","text":"JSON JSON，全称是 JavaScript Object Notation，即 JavaScript 对象标记法。 JSON 是一种轻量级（Light-Weight）、基于文本的（Text-Based）、可读的（Human-Readable）格式。 JSON 的名称中虽然带有 JavaScript，但这是指其语法规则是参考 JavaScript 对象的，而不是指只能用于 JavaScript 语言。 JSON 无论对于人，还是对于机器来说，都是十分便于阅读和书写的，而且相比 XML （另一种常见的数据交换格式），文件更小，因此迅速成为网络上十分流行的交换格式。 json 语法规则1）- 数组（Array）用方括号(“[]”)表示。 2）- 对象（Object）用大括号（”{}”）表示。 3）- 名称/值对（name/value）组合成数组和对象。 4）- 名称（name）置于双引号中，值（value）有字符串、数值、布尔值、null、对象和数组。名称/值对（name/value）之间用冒号（”：”）隔开。 5）- 并列的数据之间用逗号（“,”）分隔 实例 { “name”: “Geoff Lui”, “age”: 26 } json &amp; xmlJSON 常被拿来与 XML 做比较，因为 JSON 的诞生本来就多多少少要有取代 XML 的意思。相比 XML，JSON 的优势如下： 1）- 没有结束标签，长度更短，读写更快 2）- 能够直接被 JavaScript 解释器解析 3）- 可以使用数组 对比JSON和XML，比较相同与相异之处 json123456789&#123;&quot;name&quot;: &quot;parisjee&quot;,&quot;age&quot;: 23,&quot;friends&quot;: [&quot;Lily&quot;, &quot;Lucy&quot;, &quot;zero&quot;]&#125; xml12345678910111213141516&lt;root&gt;&lt;name&gt;parisjee&lt;/name&gt;&lt;age&gt;23&lt;/age&gt;&lt;friends&gt;Lily&lt;/friends&gt;&lt;friends&gt;Lucy&lt;/friends&gt;&lt;friends&gt;zero&lt;/friends&gt;&lt;/root&gt;``` ## json 解析与生成 在 JavaScript 中，有两个方法与此相关： **JSON.parse** 和 **JSON.stringify** 。 var str = ‘{“name”: “Geoff Lui”,”age”: 26,}’; var obj = ISON.parse(str); console.log(obj); var jsonstr = ISON.stringify(obj); console.log(jsonstr); `","categories":[{"name":"JSON","slug":"JSON","permalink":"http://paris-jee.github.io/categories/JSON/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"http://paris-jee.github.io/tags/JSON/"}]},{"title":"常量","slug":"常量","date":"2018-07-04T22:59:19.000Z","updated":"2018-07-04T23:23:30.849Z","comments":true,"path":"2018/07/05/常量/","link":"","permalink":"http://paris-jee.github.io/2018/07/05/常量/","excerpt":"","text":"常量常量也是一个简单值的标识符，正好和变量相反，在脚本执行期间这个值不能改变，也就是我们常量的值一经定义是不能对它进行重新赋值，这就是常量。 系统常量 自定义常量 魔术常量 1.常量的名称前面是没有这个$符号的2.我们的常量名称呢同样也是以字母或者下划线开始，尽量使用大写字母。3.常量可以在任何地方定义和使用。4.还有就是需要注意的就是常量一经定义不能改变。也不能取消这个定义。5.我们常量的值只能是标量，虽然说也可以使用我们的资源，但是呢我们尽量的不要去使用这个资源，更常用的呢我们常量的值用标量作为我们的值。像我们的整型、浮点类型、布尔类型，包括我们的字符串类型可以当做我们的常量的值。6.常量默认是不区分大小写的，如果需要区分大小写通过给define函数的第三个参数为true实现。 define函数定义常量constant($name)来得到这个常量的值defined(‘TEST‘)，返回值真或假PHP5.3.0以后了我们还可以通过const来定义一个常量，那之前呢const可以在类里面来定义常量，那在我们5.3.0之后呢可以使用const在类定义之外定义","categories":[],"tags":[{"name":"PHP 常量","slug":"PHP-常量","permalink":"http://paris-jee.github.io/tags/PHP-常量/"}]},{"title":"php变量","slug":"PHP变量","date":"2018-07-04T22:18:13.000Z","updated":"2018-07-04T23:22:50.524Z","comments":true,"path":"2018/07/05/PHP变量/","link":"","permalink":"http://paris-jee.github.io/2018/07/05/PHP变量/","excerpt":"","text":"变量在程序执行期间，可以变化的量。 声明变量：在php中是以$符加上变量名称 如 $a变量的名称以字母或者下划线开始，后面呢可以跟上数字、字母、下划线，这样的形式。不要包含特殊字符，什么是特殊字符呢？空格啊、叹号、*号啊、问号啊这样的都是我们的特殊字符 变量名称，严格区分大小写，什么意思呢，$a 和 $A 这是两个变量当变量名称重复的时候，相当于变量重新赋值了，后面的会覆盖之前的值php是弱类型语言,像Java，c 变量一定要声明之后才能使用，而弱类型语言比较松散，变量可以不用声明直接使用 可变变量 123456&lt;?php //可变变量的例子 $a=&apos;b&apos;; $b=&apos;c&apos;; $c=&apos;d&apos;; echo $$$a; 引用赋值 销毁变量函数unset($var):注销变量","categories":[{"name":"PHP","slug":"PHP","permalink":"http://paris-jee.github.io/categories/PHP/"}],"tags":[{"name":"PHP 变量","slug":"PHP-变量","permalink":"http://paris-jee.github.io/tags/PHP-变量/"}]},{"title":"PHP","slug":"one","date":"2017-06-17T16:00:00.000Z","updated":"2018-07-01T04:16:16.982Z","comments":true,"path":"2017/06/18/one/","link":"","permalink":"http://paris-jee.github.io/2017/06/18/one/","excerpt":"PHPPHP最早是 personal home page 的缩写，现在改称为Hypertext Proprecessor,即超文本预处理语言。PHP代码可嵌入HTML代码中 Thread safe(线程安全)简称TS和 Non Thread Safe（非线程安全）TS执行时会进行安全检查，以防止有新的请求就启动新线程的CGI执行方式而耗尽系统资源。NTS在执行时不进行线程安全检查。 PHP的两种执行方式ISAPI 和FastCGI。 PHP代码必须定义在执行块中才能执行，PHP有多种定义PHP执行块的方法a. 标准标签&lt;?php//这里写代码?&gt;b. 短标签&lt;?//这里写代码?&gt;短标签可以在php.ini文件中设置 short_tag_on 来开启。LInux/unix 系统采用多进程的工作方式，Windows系统采用多线程的工作方式。","text":"PHPPHP最早是 personal home page 的缩写，现在改称为Hypertext Proprecessor,即超文本预处理语言。PHP代码可嵌入HTML代码中 Thread safe(线程安全)简称TS和 Non Thread Safe（非线程安全）TS执行时会进行安全检查，以防止有新的请求就启动新线程的CGI执行方式而耗尽系统资源。NTS在执行时不进行线程安全检查。 PHP的两种执行方式ISAPI 和FastCGI。 PHP代码必须定义在执行块中才能执行，PHP有多种定义PHP执行块的方法a. 标准标签&lt;?php//这里写代码?&gt;b. 短标签&lt;?//这里写代码?&gt;短标签可以在php.ini文件中设置 short_tag_on 来开启。LInux/unix 系统采用多进程的工作方式，Windows系统采用多线程的工作方式。","categories":[{"name":"PHP","slug":"PHP","permalink":"http://paris-jee.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://paris-jee.github.io/tags/PHP/"},{"name":"基本概念","slug":"基本概念","permalink":"http://paris-jee.github.io/tags/基本概念/"}]}]}